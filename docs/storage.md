# Shared Storage Plan (Claim-Check Pattern)

## Overview
All functions in FAVE exchange references to artifacts via an S3-compatible object store rather than embedding binary payloads in HTTP requests. We will use **MinIO** in development and can switch to AWS S3 (or equivalent) by updating environment variables.

## Bucket Layout
```
Bucket: fave-artifacts
requests/
  {request_id}/
    input/
      original.mp4
    stage-ffmpeg-0/
    stage-librosa/
    stage-ffmpeg-1/
    stage-ffmpeg-2/
    stage-deepspeech/
    stage-ffmpeg-3/
    stage-object-detector/
    metadata/
      state.json
      logs/{stage}-{timestamp}.jsonl
tmp/
  builds/
  scratch/
```

## Naming Conventions
- `request_id`: UUID v4 generated by orchestrator.
- Each stage writes to `requests/{request_id}/{stage}/...` and returns the object URIs.
- Fan-out data (per clip/frame) should append indices, e.g., `clip_0001/`, `frame_0003.jpg`.

## Access Pattern
1. Orchestrator uploads the original video to `requests/{id}/input/original.mp4`.
2. Orchestrator invokes `stage-ffmpeg-0` with payload:
   ```json
   {
     "request_id": "...",
     "stage": "stage-ffmpeg-0",
     "input_uri": "s3://fave-artifacts/requests/{id}/input/original.mp4"
   }
   ```
3. `stage-ffmpeg-0` downloads the object, processes it, uploads new archive to `stage-ffmpeg-0/`, and responds with output URIs.
4. Orchestrator passes returned URIs to the next stage, repeating until completion.

## Environment Variables
| Variable | Purpose |
|----------|---------|
| `ARTIFACT_ENDPOINT` | MinIO/S3 endpoint URL (e.g., `http://minio-gateway:9000`). |
| `ARTIFACT_REGION` | Region string (`us-east-1` default for MinIO). |
| `ARTIFACT_BUCKET` | Default bucket (`fave-artifacts`). |
| `ARTIFACT_ACCESS_KEY` | Access key/username. |
| `ARTIFACT_SECRET_KEY` | Secret key/password. |

All functions read these variables to configure the boto3/minio client.

## Local Development Setup
1. Run MinIO locally (shortcut script):
   ```bash
   ./scripts/minio-dev.sh
   ```
2. Bootstrap bucket + alias (requires `mc` CLI):
   ```bash
   ./scripts/minio-bootstrap.sh
   ```
3. Populate `.env` or OpenFaaS secrets (see `.env.example` and `scripts/create-faassecrets.sh`):
   ```
   ARTIFACT_ENDPOINT=http://minio.default.svc.cluster.local:9000
   ARTIFACT_BUCKET=fave-artifacts
   ARTIFACT_ACCESS_KEY=faveadmin
   ARTIFACT_SECRET_KEY=favesecret
   ```
4. Ensure each function mounts these values (via `environment` or `secrets`) so runtime code can authenticate.

## Security Considerations
- Use per-environment credentials; never commit secrets. Store them in OpenFaaS secrets/Kubernetes secrets.
- Optionally enable TLS for MinIO endpoints in shared clusters.
- Implement lifecycle policies to purge old artifacts (`tmp/` objects older than 7 days, per-request data older than experiment retention policy).

## Helper Scripts
- `scripts/minio-dev.sh`: runs a local MinIO container.
- `scripts/minio-bootstrap.sh`: configures the bucket/alias using `mc`.
- `scripts/create-faassecrets.sh`: pushes artifact credentials into OpenFaaS secrets.

## Next Steps
1. Create helper module (`fave_storage.py`) wrapping S3 client interactions (download/upload/list) to avoid repetitive code.
2. Integrate storage helper into orchestrator and first stage implementation.
3. Document credential provisioning process in deployment instructions.
